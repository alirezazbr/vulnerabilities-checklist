# React Security
### 1- Cross-Site Scripting (XSS)
JavaScript lies at the heart of the client-side of any application. This is because your application's front end roughly amounts to some JavaScript code running on your browser. 
To illustrate this, let's take a simple example of an online transaction. When you carry out a transaction on a website, it runs some JavaScript to grab your credentials from the input fields and process them. However, the developers can easily run some additional JavaScript to do something detrimental with that information. 

* Avoid using `dangerouslySetInnerHTML`
```html
<div dangerouslySetInnerHTML={{__html:blog}}>
```
If we have to use this attribute, We should `Sanitize` the Data. We can do that by *DOMPurify* library.
### 2- Cross-Site Request Forgery (CSRF)
The "cross-site request" part simply means a request sent from site A that was supposed to be sent from site B. 
#### Forgery
The other part of the term, "forgery," means forcibly and illegally carrying out an action you aren't authorized to do.
So if you put two and two together, CSRF or cross-site request forgery means an unknown application forges a request to your server.
To validate the authenticity of the delete request, the user's browser stores the session token as a cookie. However, this leaves a CSRF vulnerability in your application. An attacker can send a delete request to your server with the cookie present in the browser. All they need you to do is open a link with a hidden form that triggers this delete request in the background. Let's see how this works.

- Using CORS on the Server
```javascript
app.get('/delete',(req,res)=>{
 res.set('Access-Control-Allow-Origin', '*');
 ...

})
Instead of accepting requests from any client, limit your server to accept requests from only your client. For instance, if your client is running csrfprotection-client.com and the server is running csrfprotection-server.com, replace the above lines with the following ones.
app.get('/delete',(req,res)=>{ 
   res.set('Access-Control-Allow-Origin', 'csrfprotection-client.com'); 
   ... 
})
```
- Using CSRF Tokens
```javascript
const csrfProtection = csrf({
  cookie: true
});
app.use(csrfProtection);
app.get('/getCSRFToken', (req, res) => {
  res.json({ CSRFToken: req.CSRFToken() });
});
```
### 3- SQL injection (SQLi)
Most injection attacks follow a similar pattern across all their variants. In its most primitive step, an injection attack finds a vulnerability in the application. This vulnerability provides a gateway to get unauthorized access to server files, system OS, etc. The attacker then injects some code through this gateway to steal data, modify system files, or execute shell commands.
```javascript
 const getAppVersion=async()=>{
    const response=await fetch('http://localhost:8080/?versionFile=v1.txt',{mode:'cors'});
    const data=await response.json();
    console.log(data);
  }
```
In the above code, I simply invoke a method that makes an HTTP GET request to the server at the http://localhost:8080/?versionFile=v1.txt endpoint
### 4- Broken Authentication
Broken authentication includes a bunch of authentication loopholes that an attacker exploits as vulnerabilities. An attacker can then use it to authenticate on behalf of a legitimate user of your app. This lets an attacker steal a user's credentials and access private resources for that particular user.
### 5- Server-Side Rendering (SSR) Attacks
Vulnerabilities in the server-side rendering process can expose sensitive data or lead to code injection.
*Solution*: Sanitize all data before rendering it on the server-side. Keep the server-side code updated and use secure libraries for templating.
### 6- Insecure Randomness and Links
Predictable random numbers or links allow attackers to gain unauthorized access or manipulate data.
*Solution*: Use cryptographically secure random number generators (CSPRNGs) to generate unpredictable random numbers and links. Consider libraries like randombytes for Node.js.
### 7- XML External Entities (XXE)
XML, or Extensible Markup Language, is a markup language and file format for storing, transmitting, and reconstructing arbitrary data. In addition, this language is used in the programming world to define rules for encoding documents in a format that is both human-readable and machine-readable.
Generally, you have done most of the work as long as you keep your libraries updated. Your application is likely implementing react-xml-parser, which already comes with protections against this vulnerability. Additionally, for most libraries, external entities are disabled by default. 
### 8- Arbitary Code Execution
Attackers can execute arbitrary code on your server, granting complete control of your application.
*Solution*: Validate and sanitize all user input before processing it on the server-side. Never allow user-controlled code execution on the server.
### 9- Zip Slip Vulnerabilitiy
User-controlled file paths during zip extraction allow attackers to overwrite arbitrary files on the server.
Solution: Validate and restrict user-controlled file paths during the extraction process. Use libraries designed for secure zip extraction.
### 10- Lack of End-to-End Encryption
Unencrypted data is vulnerable to interception during transmission or at rest.
*Solution*: Implement HTTPS to encrypt communication between the client and server. Encrypt sensitive data at rest using industry-standard encryption algorithms.
### 11- Broken Access Control
If a regular user gets access to the admin page, you know what that means. How do you avoid that? The act of avoiding that is broken access control.
```html
Import { Redirect } from ‘react-router-dom’;

Import { useAuth } from ‘../hooks’;

Const AuthGuard = () => {
Const { isAuth } = useAuth();

if(isAuth) {
Return <Redirect to=’/login’ />
```
*Solution*: Implement role-based access control (RBAC) or similar mechanisms to restrict access based on user permissions. Regularly review and update access control policies.
### 12- Insecure Dependencies
Vulnerabilities in third-party libraries used in your application can be exploited to gain access to your system.
*Solution*: Use libraries from trusted sources, keep dependencies updated, and monitor for known vulnerabilities. Consider using a security scanner to identify potential issues.
### 13- Content Security Policy (CSP) Support
A Content Security Policy (CSP) is a set of rules that define what content can be loaded on a web page. It is used to prevent the following:
- XSS attacks by restricting the sources from which JavaScript can be loaded.
- CSRF attacks by restricting the sources from which forms can be submitted.
- SQL injection attacks by restricting the sources from which SQL statements can be executed.
- Prevent DoS attacks by restricting the sources from which requests can be made.
- And any other attack involving loading content from an untrusted source.
 
To implement a CSP, you need to add a meta tag to the head of your HTML document. The meta tag should look like this:

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; script-src 'self'"
/>
```
### 14- Using HTTPS
HTTPS is a protocol that encrypts the connection between a web browser and a web server. It ensures that the data sent between the two is secure and cannot be intercepted by a third party. It also ensures that a third party does not modify the data sent between the two. HTTPS is essential for securing your Reactjs application because it prevents attackers from intercepting sensitive information like session cookies and login credentials.
### 15- Keeping Reactjs and dependencies updated
Reactjs is an open-source project and is constantly being updated with new features and bug fixes. Contributors to the Reactjs project are constantly working to improve the framework's security and fix any Reactjs security vulnerabilities discovered. So it is crucial to keep your Reactjs application up-to-date with the latest version of Reactjs and its dependencies. By keeping your Reactjs application up-to-date, you can ensure it is secure and bug-free.
### 16- Sanitizing and rendering HTML
Since JSX is just JavaScript, it can be used to execute arbitrary code. This means that if you render user input as JSX, it could be used to execute malicious code.
To prevent this, you should sanitize user input before rendering it as JSX. This can be done using a library like DOMPurify, which provides a set of functions for sanitizing HTML.